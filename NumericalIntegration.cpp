#include "NumericalIntegration.hpp"
#include "MeshHelperFunctions.hpp"
#include <numeric>

namespace gfd {

	//1D weights
	const std::vector<double> valueWeights1D{
	0.202578241925561272880620199967519314839,
	0.198431485327111576456118326443839324819,
	0.198431485327111576456118326443839324819,
	0.186161000015562211026800561866422824506,
	0.186161000015562211026800561866422824506,
	0.166269205816993933553200860481208811131,
	0.166269205816993933553200860481208811131,
	0.139570677926154314447804794511028322521,
	0.139570677926154314447804794511028322521,
	0.107159220467171935011869546685869303416,
	0.107159220467171935011869546685869303416,
	0.070366047488108124709267416450667338467,
	0.070366047488108124709267416450667338467,
	0.030753241996117268354628393577204417722,
	0.030753241996117268354628393577204417722 };
	const std::vector<double> abscissas{ 0.0,
	-0.20119409399743452230062830339459620781,
	0.20119409399743452230062830339459620781,
	-0.39415134707756336989720737098104546836,
	0.39415134707756336989720737098104546836,
	-0.57097217260853884753722673725391064124,
	0.57097217260853884753722673725391064124,
	-0.72441773136017004741618605461393800963,
	0.72441773136017004741618605461393800963,
	-0.84820658341042721620064832077421685137,
	0.84820658341042721620064832077421685137,
	-0.93727339240070590430775894771020947124,
	0.93727339240070590430775894771020947124,
	-0.987992518020485428489565718586612581147,
	0.987992518020485428489565718586612581147 };

	//2D weights
	const std::vector<double> valueWeights2D{
	0.08117796029686715951547596874982357,
	0.01232404350690949411847390101623284,
	0.01232404350690949411847390101623284,
	0.01232404350690949411847390101623284,
	0.06282800974441010728333942816029398,
	0.06282800974441010728333942816029398,
	0.06282800974441010728333942816029398,
	0.01222037904936452975521221500393789,
	0.01222037904936452975521221500393789,
	0.01222037904936452975521221500393789,
	0.06770134895281150992098886182322559,
	0.06770134895281150992098886182322559,
	0.06770134895281150992098886182322559,
	0.04021969362885169042356688960756866,
	0.04021969362885169042356688960756866,
	0.04021969362885169042356688960756866,
	0.01476227271771610133629306558778206,
	0.01476227271771610133629306558778206,
	0.01476227271771610133629306558778206,
	0.01476227271771610133629306558778206,
	0.01476227271771610133629306558778206,
	0.01476227271771610133629306558778206,
	0.04072799645829903966033695848161786,
	0.04072799645829903966033695848161786,
	0.04072799645829903966033695848161786,
	0.04072799645829903966033695848161786,
	0.04072799645829903966033695848161786,
	0.04072799645829903966033695848161786 };
	const std::vector<std::vector<double>> pointWeights2D{
	{0.33333333333333333333333333333333333, 0.33333333333333333333333333333333333, 0.33333333333333333333333333333333333},
	{0.03093835524543078489519501499130475, 0.03093835524543078489519501499130475, 0.9381232895091384302096099700173905},
	{0.03093835524543078489519501499130475, 0.9381232895091384302096099700173905, 0.03093835524543078489519501499130475},
	{0.9381232895091384302096099700173905, 0.03093835524543078489519501499130475, 0.03093835524543078489519501499130475},
	{0.43649818113412884191761527655997324, 0.43649818113412884191761527655997324, 0.1270036377317423161647694468800535},
	{0.43649818113412884191761527655997324, 0.1270036377317423161647694468800535, 0.43649818113412884191761527655997324},
	{0.1270036377317423161647694468800535, 0.43649818113412884191761527655997324, 0.43649818113412884191761527655997324},
	{0.49898476370259326628798698383139087, 0.49898476370259326628798698383139087, 0.0020304725948134674240260323372183},
	{0.49898476370259326628798698383139087, 0.0020304725948134674240260323372183, 0.49898476370259326628798698383139087},
	{0.0020304725948134674240260323372183, 0.49898476370259326628798698383139087, 0.49898476370259326628798698383139087},
	{0.21468819795859433660687581387825086, 0.21468819795859433660687581387825086, 0.5706236040828113267862483722434983},
	{0.21468819795859433660687581387825086, 0.5706236040828113267862483722434983, 0.21468819795859433660687581387825086},
	{0.5706236040828113267862483722434983, 0.21468819795859433660687581387825086, 0.21468819795859433660687581387825086},
	{0.11368310404211339020529315622836178, 0.11368310404211339020529315622836178, 0.7726337919157732195894136875432764},
	{0.11368310404211339020529315622836178, 0.7726337919157732195894136875432764, 0.11368310404211339020529315622836178},
	{0.7726337919157732195894136875432764, 0.11368310404211339020529315622836178, 0.11368310404211339020529315622836178},
	{0.82561876616486290435880620030835800, 0.15974230459185018980086078822500751, 0.0146389292432869058403330114666345},
	{0.82561876616486290435880620030835800, 0.0146389292432869058403330114666345, 0.15974230459185018980086078822500751},
	{0.0146389292432869058403330114666345, 0.82561876616486290435880620030835800, 0.15974230459185018980086078822500751},
	{0.15974230459185018980086078822500751, 0.82561876616486290435880620030835800, 0.0146389292432869058403330114666345},
	{0.15974230459185018980086078822500751, 0.0146389292432869058403330114666345, 0.82561876616486290435880620030835800},
	{0.0146389292432869058403330114666345, 0.15974230459185018980086078822500751, 0.82561876616486290435880620030835800},
	{0.64047231013486526767703659081896681, 0.31178371570959900000000000000000000, 0.0477439741555357323229634091810332},
	{0.64047231013486526767703659081896681, 0.0477439741555357323229634091810332, 0.31178371570959900000000000000000000},
	{0.0477439741555357323229634091810332, 0.64047231013486526767703659081896681, 0.31178371570959900000000000000000000},
	{0.31178371570959900000000000000000000, 0.64047231013486526767703659081896681, 0.0477439741555357323229634091810332},
	{0.31178371570959900000000000000000000, 0.0477439741555357323229634091810332, 0.64047231013486526767703659081896681},
	{0.0477439741555357323229634091810332, 0.31178371570959900000000000000000000, 0.64047231013486526767703659081896681} };

	//5th order accurate rule with 7 points
	/*const std::vector<double> valueWeights2D{
	0.12593918054482715259568394550018133,
	0.12593918054482715259568394550018133,
	0.12593918054482715259568394550018133,
	0.13239415278850618073764938783315200,
	0.13239415278850618073764938783315200,
	0.13239415278850618073764938783315200,
	0.22500000000000000000000000000000000 };
	const std::vector<std::vector<double>> pointWeights2D{
	{0.10128650732345633880098736191512383, 0.10128650732345633880098736191512383, 0.79742698535308732239802527616975234},
	{0.10128650732345633880098736191512383, 0.79742698535308732239802527616975234, 0.10128650732345633880098736191512383},
	{0.79742698535308732239802527616975234, 0.10128650732345633880098736191512383, 0.10128650732345633880098736191512383},
	{0.47014206410511508977044120951344760, 0.47014206410511508977044120951344760, 0.05971587178976982045911758097310480},
	{0.47014206410511508977044120951344760, 0.05971587178976982045911758097310480, 0.47014206410511508977044120951344760},
	{0.05971587178976982045911758097310480, 0.47014206410511508977044120951344760, 0.47014206410511508977044120951344760},
	{0.33333333333333333333333333333333333, 0.33333333333333333333333333333333333, 0.33333333333333333333333333333333333} };*/

	//3D weights
	const std::vector<double> valueWeights3D{
	0.0055506369892575143418809366482257603519,
	0.0061477532144464387684901268338867945136,
	0.0051590955749935499080806930690373245239,
	0.0039623224773949903171147359845263972165,
	0.0122416089107120741950345809997084030194,
	0.0020848684347424200496652947164514989730,
	0.0150117871992395101350516176828868002722,
	0.0311559663929422355492256384996583339115,
	0.0121854560969498467254841759461280074991,
	0.0080823135152169511925032464725271711587,
	0.0105246360896138515805684135238220838391,
	0.0069932758440917707162929718494165442376,
	0.0214188429201399578660106111037087714380,
	0.0198485088752602342827212554194472283045,
	0.0264922236573042421878390043563721457106,
	0.0092227754115176652073485709612446217959,
	0.0019933610862646123018956261348506803982,
	0.0081705838127425004218848041573068520374,
	0.0219003543865817471764148400440692309617,
	0.0119718586520223062694873798654615265702,
	0.0146313548237887034197455024791026498177,
	0.0217132517145139277735325364909027328012,
	0.0129937813180861740442830541223165928006,
	0.0055242179505021764610018164567281177012,
	0.0064528995390064073240949761498731836564,
	0.0187755686884473536393211110493717760487,
	0.0125986849981953202653051768081714601785,
	0.0025358223735157769860687929177347550560,
	0.0131488815740120676426574243151347601406,
	0.0030921390901531557956685249976364429927,
	0.0157825619200382209898592804138019182098,
	0.0177676367340684506332345942847463972973,
	0.0090932089158889553249904556905144005607,
	0.0043150661426652692684610834304746702916,
	0.0089940648210183191679929247640845601258,
	0.0117947436103944399048801763271119252993,
	0.0101745127349676224692933101094137583732,
	0.0103059892304041852971357457395725538231,
	0.0031716809575973847486692011493386928131,
	0.0090538419255349569554516698384081329632,
	0.0094450822787096969444966363951185992021,
	0.0040318614533774016293653453859405672038,
	0.0085852270191038410114375689064710072893,
	0.0153459060028009356274568400393104050908,
	0.0048734421145304412370296003483615626995,
	0.0021390058461497992678074391380700316785,
	0.0029679157516668718678036831850609601096,
	0.0035183608831277067389845958441789268272,
	0.0025550501021846111621243072002585047687,
	0.0052514577005576748370702323470782424835,
	0.0167601773895389111965933426310302923361,
	0.0023241294610879421958894806477436318496,
	0.0051325174455107924456652262247732966879,
	0.0059046029082899636579469551566023262182,
	0.0096395738591239443566217843559912307932,
	0.0063528078855466799034341587501076411689,
	0.0058312707530735254136293033146276654784,
	0.0021437870095377759834074184537547428224,
	0.0097165625700606125449447284589328171345,
	0.0152329873054885438087785440811759813354,
	0.0090020012445822761308823221998411993364,
	0.0108696468782792356714875506251212345999,
	0.0076345931264045745340360822341765849205,
	0.0225088924043153988320657057568411572513,
	0.0281745419258977493974161315976854901183,
	0.0155367064941410244731181922111168038418,
	0.0169923475284808198490104788089428776000,
	0.0045108195708875076934978985268098444656,
	0.0051145574115515387063820206988215209266,
	0.0068552285837802659078603027586227330845,
	0.0188243335720900082947432242361924442531,
	0.0201612299329970311249580832358879629617,
	0.0156058622259132449702220323632571371851,
	0.0033669688310285881452572423989605357509,
	0.0101892962941285026382912500212337898746,
	0.0153076021022552832443673916137003498498,
	0.0089541052307377953555433562726852051524,
	0.0024160231170167761695144359006487261510,
	0.0293096226368663433436814558056598151779,
	0.0139542097962516100750068464768006228127,
	0.0072471266607997818834425094811421610309,
	0.0062342914788512917262043309452061098498,
	0.0047936933421967065190600286235952062080,
	0.0290053908701420438541371220761101192018,
	0.0063389780688720995807384652563696750323,
	0.0176538528259637105467740665542173794365,
	0.0191069549781438121500937410745413858369,
	0.0033015144570981130840324657159508875554,
	0.0028127611709896954152327919281913995177,
	0.0078586335779980878641974184188415443482,
	0.0031850246322159351419600431069833648105,
	0.0065488308133980405624117526928065401442,
	0.0057844936458760484348027364224023138810,
	0.0250500002261480995444414512928717869666 };
	const std::vector<std::vector<double>> pointWeights3D{
	 {0.024586425223968086324551897424084637602,
	  0.7711844778232402089131167963293973218562,
	  0.030149476635775709133333550458901435075,
	  0.174079620317015995628997755787616605467},
	 {0.037233030088103544332322812656255890127,
	  0.5394395795547526087888845237557289772779,
	  0.404452877552081177796039110690981968638,
	  0.018874512805062669082753552897033163957},
	 {0.143385205098447554670462843614157868204,
	  0.645757520465285451743046551398987675527,
	  0.0024687487558465326577452239327590741021,
	  0.208388525680420460928745381054095382166},
	 {0.125138103315674423468356806587719033452,
	  0.035206867250910605828819645175140722766,
	  0.814674695357489335887685846272026732244,
	  0.0249803340759256348151377019651135115385},
	 {0.317879145061671381581350999470037828870,
	  0.202143667520649522199101773984772804958,
	  0.022980550715343346849807896251892428348,
	  0.4569966367023357493697393302932969378245},
	 {0.002421510824290422958309469009821587115,
	  0.028709462926826182976904639518219795472,
	  0.165595710768352266380592616877514841566,
	  0.803273315480531127684193274594443775848},
	 {0.558199763089584944750325857385083092937,
	  0.141931798748882889690967963273438125284,
	  0.037474378133749342571976518316117663409,
	  0.2623940600277828229867296610253611183698},
	 {0.187680441239837536762228735656446754163,
	  0.270122388743190010259448970531413983029,
	  0.273271419323451026963368054817355688860,
	  0.2689257506935214260149542389947835739487},
	 {0.144208439880063998405061905661463626533,
	  0.2510183910688732451608238355827184584171,
	  0.072094393510054992891945198561458536953,
	  0.5326787755410077635421690601943593780966},
	 {0.305301247566255295740520741666547427421,
	  0.008015049556647654378154130639620985606,
	  0.451735313172501196884811015559797534781,
	  0.234948389704595852996514112134034052192},
	 {0.037000378426667781074220616578368660144,
	  0.125611232214661904922845486873337456365,
	  0.7008259627499786132895417230774040793923,
	  0.136562426608691700713392173470889804099},
	 {0.428324644574557798421880159364745260870,
	  0.3082991524611926477799885231433942601359,
	  0.009474230997113106777818460899936754716,
	  0.253901971967136447020312856591923724278},
	 {0.441167429201299278164488495859344286528,
	  0.289450536294409354713235706707910534673,
	  0.1012872995794822845282599027035212809858,
	  0.1680947349248090825940158947292238978134},
	 {0.079724152142979338813726122175063546198,
	  0.483149250392916685620271340941389822409,
	  0.279296127839811641329955616507326873113,
	  0.1578304696242923342360469203762197582804},
	 {0.255766959614746892520337776314810407204,
	  0.093926781513942231466525086029357705751,
	  0.294975229465335345480193369983177439912,
	  0.355331029405975530532943767672654447133},
	 {0.600811199665432621571829358412280422850,
	  0.2808816621594445584783806615932996101835,
	  0.023518360349339504677068053658999333919,
	  0.094788777825783315272721926335420633047},
	 {0.025890983776192788358128804529716561381,
	  0.0234397612031466440286369786041774212278,
	  0.034535084403350958880018722541467110655,
	  0.9161341706173096087332154943246389067359},
	 {0.011100084168031000276280230597465738509,
	  0.555645005196962878040672877413901497267,
	  0.1636507721311736114589672734770932134960,
	  0.269604138503832510224079618511539550728},
	 {0.122470134547982505350876243415752869702,
	  0.177322993507837634116682478409508456729,
	  0.473784751619088624230228398795259814527,
	  0.226422120325091236302212879379478859042},
	 {0.311184210340775563877499658545348673149,
	  0.144175911492444186169645920688148628445,
	  0.5220675824440285746446274275553420214640,
	  0.022572295722751675308226993211160676942},
	 {0.677050896707521674407603240387244094913,
	  0.115211177549809887329713429938086339026,
	  0.1090127466489408759852645207976467946541,
	  0.098725179093727562277418808877022771406},
	 {0.181154467746518094598113036937158503598,
	  0.4733178686519731818183475000870156361563,
	  0.151714015847759890180628474611701040546,
	  0.193813647753748833402910988364124819700},
	 {0.345466264168302457609877740622160805645,
	  0.5122225271882200785089054582572471234359,
	  0.028719566427552803285470751735085526198,
	  0.113591642215924660595746049385506544722},
	 {0.006517097892517367658147728794771448409,
	  0.0962046779452247072389809102507416457098,
	  0.5698867145402618178669208025391540089950,
	  0.327391509621996107235950558415332896886},
	 {0.031944583357501936521629744716850449783,
	  0.307657160391516008353008466906129995539,
	  0.024816553006698880719481502495384943388,
	  0.6355817032442831744058802858816346112899},
	 {0.429539293538599014839908643596488304374,
	  0.0824809488886036833027945412275189356195,
	  0.1103757607585965185763483018119259393591,
	  0.377603996814200783280948513364066820648},
	 {0.162900979700010978769406493989659227782,
	  0.0223126161782778809892625706448296742793,
	  0.339637541774684139962278142956681169229,
	  0.475148862347027000279052792408829928709},
	 {0.021401105135118849760427027638040907238,
	  0.127194338733586801029394996315390853769,
	  0.0170976174706215527971857147709433625501,
	  0.8343069386606727964129922612756248764428},
	 {0.442778695494517004820443701532762956760,
	  0.023580209723993884441743218560453786710,
	  0.239954131595569925030575931076592047595,
	  0.293686963185919185707237148830191208936},
	 {0.015771049863894468802648883919886217499,
	  0.126132877485423499324097987765462589806,
	  0.827729796998234878835537568393779439327,
	  0.0303662756524471530377155599208717533675},
	 {0.088629842503747200660660905296710574311,
	  0.5433860470400686352424613881639325144827,
	  0.079018722164231409188029520192001787248,
	  0.2889653882919527549088481863473551239583},
	 {0.088283230221032934459813253404645545430,
	  0.3330983043307960739597017522707304748360,
	  0.127022744562832199727860100451611807330,
	  0.451595720885338791852624893873012172404},
	 {0.146193898964204862293429935068819080838,
	  0.142868227350987772914025945586962213448,
	  0.021174352303942007242689043897656972813,
	  0.6897635213808653575498550754465617329014},
	 {0.782460191097817577691772330974151664252,
	  0.014293678102444836412643747142573945172,
	  0.163745879306136074324218025714835856867,
	  0.0395002514936015115713658961684385337092},
	 {0.164496620618727714520499002971479241752,
	  0.1682572149812816856933966934635593811767,
	  0.597540184230500027956876294385849529816,
	  0.0697059801694905718292280091791118472550},
	 {0.037830256094612230781418393139494393848,
	  0.137196683065723231414039959711951528596,
	  0.108501148082759486550150973965574445017,
	  0.716471912756905051254390673182979632539},
	 {0.160195732411542292883569885422849999748,
	  0.343489892636919368230933598227822446493,
	  0.479058724871692859832040386946091070706,
	  0.017255650079845479053456129403236483053},
	 {0.019353573932823841053220563663306008119,
	  0.306691309067315600049427419384774554414,
	  0.382289085879555073831426051229633480235,
	  0.291666031120305485065925965722285957232},
	 {0.584322623699192168390229480687760607410,
	  0.028807250464156035093710552377259743152,
	  0.383312273233856527556924295047207555652,
	  0.003557852602795268959135671887772093786},
	 {0.020902484092295367963415105157324007906,
	  0.273446145397616084168133655918350819059,
	  0.5513270326941551718398012373605391128035,
	  0.154324337815933376028650001563786060232},
	 {0.379531066253823317964316313015528714969,
	  0.026001577959626183180942491817233575923,
	  0.5363659992766203962178005396587666005182,
	  0.058101356509930102636940655508471108590},
	 {0.116538761338061068507371505193161768456,
	  0.0313104511338085279018224506568116801894,
	  0.028501979442441433303253972725455385687,
	  0.823648808085688970287552071424571165668},
	 {0.345416697185168943851087380760312402897,
	  0.355061934545681610719659547525550625796,
	  0.291707428657239658366290053352721561096,
	  0.0078139396119097870629630183614154102116},
	 {0.150290415598990000041037022261517095396,
	  0.691605469266916012252492628604559198875,
	  0.0681977016919668791118697314600402277009,
	  0.089906413442127108594600617673883478028},
	 {0.530748508672965860999623786706812106154,
	  0.0094052272283362866603857724854394831656,
	  0.0457469550173751703508312265792518765282,
	  0.414099309081322681989159214228496534153},
	 {0.028918093741416521061526843135685089784,
	  0.0232551324539047489103106893057642487340,
	  0.915019828059501526843747663787470343618,
	  0.0328069457451772031844148037710803178636},
	 {0.265290609501619592703183693982816741736,
	  0.702440264961588700760192569586237123913,
	  0.009157891497218531872209559896681889942,
	  0.023111234039573174664414176534264244409},
	 {0.119338162547109570745101841659998825005,
	  0.7879831247050387469466224098675459493022,
	  0.089763202417867738927453476983203463402,
	  0.0029155103299839433808222714892517622909},
	 {0.910093795254673946919447610268647633817,
	  0.0350530629606904331715743639946044873256,
	  0.0328934138441180618869605398330810207750,
	  0.021959727940517558022017485903666858083},
	 {0.519111791947299134554941759066178600908,
	  0.4345305394862628451678261315626827968928,
	  0.0252926152095714884229620857279643590191,
	  0.021065053356866531854270023643174243180},
	 {0.503805943593745109362152486078346412085,
	  0.1468760245223108931111485948116706183507,
	  0.3129930001468372293924200597958654149659,
	  0.036325031737106768134278859314117554598},
	 {0.017076059416525432537069278061834808422,
	  0.907654818128354503261480643889714029660,
	  0.043836618078476730419793724252196178631,
	  0.031432504376643333781656353796254983287},
	 {0.779511500670492769283456969367952765330,
	  0.114922602677344669603884355530710752573,
	  0.0173725615955244095087394180848574058360,
	  0.0881933350566381516039192570164790762614},
	 {0.102014205623688962178661534475983465546,
	  0.161942637306232740815422015830376872254,
	  0.720116576093354988668214962880597104333,
	  0.0159265809767233083377014868130425578673},
	 {0.095343280547652655532112747077720280486,
	  0.025233036380728764138705300416092285828,
	  0.1551497086465964021051265094377981835784,
	  0.724273974425022178224055443068389250107},
	 {0.008319855382905824583537956111626143146,
	  0.520052988544047412808386719379764946555,
	  0.3636659889353487396496850827343205636366,
	  0.107961167137698022958390241774288346663},
	 {0.006490898625513962370288569800919160644,
	  0.3485982841079376577939723977811040851610,
	  0.121467251205617964195544817719464185676,
	  0.523443566060930415640194214698512568519},
	 {0.083608862493507309621097041549874407826,
	  0.867729476024243266847146670328386231617,
	  0.0062521780546749316160654793301964568688,
	  0.0424094834275744919156908087915429036879},
	 {0.323925848537542505506644918027295276298,
	  0.5537603813843986937532057502744425555423,
	  0.102776478420296773160734465143775149902,
	  0.019537291657762027579414866554487018258},
	 {0.057904564883428635097944113018197368254,
	  0.133582851361884819083055049162797312630,
	  0.4249040259083643723775480342665087120882,
	  0.383608557846322173441452803552496607028},
	 {0.152326891922316783259584549001196098908,
	  0.1054315111602953591581012581127514329643,
	  0.6435348221542448359794088415376436152470,
	  0.098706774763143021602905351348408852881},
	 {0.658931289976468868270112506675318665482,
	  0.028117284133717343562262376880917135224,
	  0.1108904210213228581398864405625308871023,
	  0.202061004868490930027738675881233312192},
	 {0.140316398703827899667965543138889920294,
	  0.386947924866330985303753016305710762817,
	  0.0109091652188695657263398195911208780800,
	  0.4618265112109715493019416209642784388094},
	 {0.102403205926787482760313637339740582245,
	  0.1452594763567463043520525392108162546572,
	  0.234911361430609445838093619128203736295,
	  0.5174259562858567670495402043212394268024},
	 {0.285782724159465591237660047349643787794,
	  0.239521668999070826901684710589482467417,
	  0.1283549647759243201066746475661790758393,
	  0.346340642065539261753980594494694668950},
	 {0.542862406252028442512667121427126768321,
	  0.287790765267758187580330575240980536195,
	  0.1367717521130778528194161990863472840847,
	  0.0325750763671355170875861042455454113995},
	 {0.249870438510155994387072842289783157168,
	  0.4222383818394575194775160242066146096880,
	  0.042917237666677621842204397589448154875,
	  0.2849739419837088642932067359141540782692},
	 {0.025762162323397897594866933115202391846,
	  0.750772293893801715539313854978505183490,
	  0.199552900709034594422217305119570466337,
	  0.023912643073765792443601906786721958327},
	 {0.030044413031745991666790566243502184398,
	  0.024298767767161547527716287802968165845,
	  0.7812922981934326580559953935377149150797,
	  0.164364521007659802749497752415814734677},
	 {0.026324137607911517594613233988257990315,
	  0.318909750901157812459755271478736702946,
	  0.623796677577883756668448488051725727003,
	  0.030969433913046913277183006481279579736},
	 {0.104273175684451026011278104174589112477,
	  0.3383914130243770896231054551445662156438,
	  0.454050031755012838585827062944892570541,
	  0.1032853795361590457797893777359521013383},
	 {0.316926935147622408811763200967814638700,
	  0.419393023646009756244057332694602935651,
	  0.1678534563045752019724369231647127582863,
	  0.095826584901792632971742543172869667363},
	 {0.050890125128966475159852908106414008757,
	  0.3431256019434479283682952436103737330849,
	  0.2552381855213296999877328646021352736475,
	  0.350746087406255896484118983681076984511},
	 {0.028099346679657331338873665215976536503,
	  0.009312024647538243369826863870214518126,
	  0.575720005798770144217832755213268536157,
	  0.386868622874034281073466715700540409214},
	 {0.037356896450741645301193478504509577434,
	  0.710551229203001273157773016571538899797,
	  0.144349549150834578180377530858831230850,
	  0.1077423251954225033606559740651202919192},
	 {0.119470677408559228844170692019374079586,
	  0.0390079208174733443292381315527690886826,
	  0.5568716912871344172531505911062481200083,
	  0.284649710486833009573440585321608711724},
	 {0.032736487939546072561129575359748503420,
	  0.034413366386708231076594755654027907072,
	  0.3490653137444714060340777064140682911178,
	  0.5837848319292742903281979625721552983907},
	 {0.274801742675813744854380864643279693741,
	  0.030482936103575377910242530985725680041,
	  0.689354579857344228241957374614038645928,
	  0.005360741363266648993419229756955980291},
	 {0.451746644167970192388075142399173798763,
	  0.149359078771279288472119509293564176599,
	  0.2203449174658770181790611637863915575834,
	  0.178549359594873500960744184520870467055},
	 {0.561202916153142230678873608479519800030,
	  0.030716426468808937009979344712218774569,
	  0.303979842649248436552566709991620851933,
	  0.104100814728800395758580336816640573468},
	 {0.301822949643897176151498906887629265157,
	  0.008511440408983542995050164946299476540,
	  0.158711067239331793027561757605247672901,
	  0.5309545427077874878258891705608235854026},
	 {0.397875531744693083194506963784708451236,
	  0.0653996209835180193978083177466751452554,
	  0.014497888533002320271829759965227282756,
	  0.522226958738786577135854958503389120753},
	 {0.267586749287198886678536624758828643045,
	  0.0198222333854801471353488340080829834709,
	  0.031932603045940630392440321174838479921,
	  0.6806584142813803357936742200582498935634},
	 {0.285321758067298553132196934269682802470,
	  0.279865292460383972693728366159015478924,
	  0.3373176094562046030056229953361666121428,
	  0.097495340016112871168451704235135106463},
	 {0.025427878605678061053529615812493388072,
	  0.5497643401108277058062958801473279626691,
	  0.025929410713816946826202273467383313484,
	  0.398878370569677286313972230572795335775},
	 {0.152509186619158917223026046264364533827,
	  0.5620256156092019078417259420438073709208,
	  0.249436818062170008567796825168436762253,
	  0.036028379709469166367451186523391333000},
	 {0.223962064538063696012587628185518082958,
	  0.089216979965616418576336956535659145865,
	  0.114638401437019911295758309373415019617,
	  0.572182554059299974115317105905407751560},
	 {0.763980987597056172758626956640760807957,
	  0.195549430066187139396846556346812005131,
	  0.032545788012622124285492387706501755971,
	  0.0079237943241345635590340993059254309413},
	 {0.831159773842408502766947048621988480305,
	  0.014164519920845215292980821476190494311,
	  0.0313704173326636791264068004873438206443,
	  0.1233052889040826028136653294144772047397},
	 {0.168205406494695232366921429123271496487,
	  0.020019464138805672992795870526575811507,
	  0.7001218163520293386598732730014148879051,
	  0.1116533130144697559804094273487378041001},
	 {0.683484993496602139109514616175980156982,
	  0.043832033736204037333203761486560428607,
	  0.004485252771218634152239824982200871352,
	  0.2681977199959751894050417973552585430585},
	 {0.005901076425591535252910314374185434898,
	  0.1715297304385654691263517855082133499808,
	  0.2718078178716385609692895672048277991550,
	  0.550761375264204434651448332912773415966},
	 {0.729783333971520381363680953607794419627,
	  0.0978980451700820960007727232653032563149,
	  0.1570521893868311466555774334537946151786,
	  0.0152664314715663759799688896731077088798},
	 {0.303204116046799036459982069248376950626,
	  0.095203749770050551603538318922135405742,
	  0.441026578450119737926396457599948346536,
	  0.1605655557330306740100831542295392970961} };

	//compute the mean of fn over the interval with endpoints x0 and x1
	double integralAverage(const std::function<double(double)>& fn, double x0, double x1) {
		double edgeVector = x1 - x0;
		double edgePosition = x0 + 0.5 * edgeVector;
		double sum = 0;
		for (uint j = 0; j < valueWeights1D.size(); ++j) {
			double evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
			sum += valueWeights1D[j] * fn(evaluationPoint);
		}
		return 0.5 * sum;
	}

	//compute the mean of fn over the line segment with endpoints node0 and node1 in 2D
	double integralAverage(const std::function<double(Vector2)>& fn, const Vector2& node0, const Vector2& node1) {
		Vector2 edgeVector = node1 - node0;
		Vector2 edgePosition = node0 + 0.5 * edgeVector;
		double sum = 0;
		for (uint j = 0; j < valueWeights1D.size(); ++j) {
			Vector2 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
			sum += valueWeights1D[j] * fn(evaluationPoint);
		}
		return 0.5 * sum;
	}

	//compute the mean of fn over the line segment with endpoints node0 and node1 in 3D
	double integralAverage(const std::function<double(Vector3)>& fn, const Vector3& node0, const Vector3& node1) {
		Vector3 edgeVector = node1 - node0;
		Vector3 edgePosition = node0 + 0.5 * edgeVector;
		double sum = 0;
		for (uint j = 0; j < valueWeights1D.size(); ++j) {
			Vector3 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
			sum += valueWeights1D[j] * fn(evaluationPoint);
		}
		return 0.5 * sum;
	}

	//compute the mean of fn over the triangle with the given nodes in 2D
	double integralAverage(const std::function<double(Vector2)>& fn, const Vector2& node0, const Vector2& node1, const Vector2& node2) {
		double sum = 0;
		for (uint j = 0; j < valueWeights2D.size(); ++j) {
			sum += valueWeights2D[j] * fn(pointWeights2D[j][0] * node0 + pointWeights2D[j][1] * node1 + pointWeights2D[j][2] * node2);
		}
		return sum;
	}

	//compute the mean of fn over the triangle with the given nodes in 3D
	double integralAverage(const std::function<double(Vector3)>& fn, const Vector3& node0, const Vector3& node1, const Vector3& node2) {
		double sum = 0;
		for (uint j = 0; j < valueWeights2D.size(); ++j) {
			sum += valueWeights2D[j] * fn(pointWeights2D[j][0] * node0 + pointWeights2D[j][1] * node1 + pointWeights2D[j][2] * node2);
		}
		return sum;
	}

	//compute the mean of fn over the tetrahedron with the given nodes in 3D
	double integralAverage(const std::function<double(Vector3)>& fn, const Vector3& node0, const Vector3& node1, const Vector3& node2, const Vector3& node3) {
		double sum = 0;
		for (uint j = 0; j < valueWeights3D.size(); ++j) {
			sum += valueWeights3D[j] * fn(pointWeights3D[j][0] * node0 + pointWeights3D[j][1] * node1 + pointWeights3D[j][2] * node2 + pointWeights3D[j][3] * node3);
		}
		return sum;
	}

	//discretise 0-form in 2D as 0-cochain
	void discretise0Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector2)>& fn) {
		for (uint i = 0; i < mesh.getNodeSize(); ++i) {
			discreteForm[i] = fn(mesh.getNodePosition2(i));
		}
	}

	//discretise 0-form in 3D as 0-cochain
	void discretise0Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector3)>& fn) {
		for (uint i = 0; i < mesh.getNodeSize(); ++i) {
			discreteForm[i] = fn(mesh.getNodePosition3(i));
		}
	}

	//discretise 0-form in 4D as 0-cochain
	void discretise0Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector4)>& fn) {
		for (uint i = 0; i < mesh.getNodeSize(); ++i) {
			discreteForm[i] = fn(mesh.getNodePosition(i));
		}
	}

	//discretise 1-form in 2D as 1-cochain by integrating numerically
	void discretise1Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<Vector2(Vector2)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			const Buffer<uint>& n = mesh.getEdgeNodes(i);
			Vector2 edgeVector = mesh.getNodePosition2(n[1]) - mesh.getNodePosition2(n[0]);
			Vector2 edgePosition = mesh.getNodePosition2(n[0]) + 0.5 * edgeVector;
			double sum = 0;
			for (uint j = 0; j < valueWeights1D.size(); ++j) {
				Vector2 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
				sum += valueWeights1D[j] * edgeVector.dot(fn(evaluationPoint));
			}
			discreteForm[i] = 0.5 * sum;
		}
	}

	//discretise 1-form in 3D as 1-cochain by integrating numerically
	void discretise1Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<Vector3(Vector3)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			const Buffer<uint>& n = mesh.getEdgeNodes(i);
			Vector3 edgeVector = mesh.getNodePosition3(n[1]) - mesh.getNodePosition3(n[0]);
			Vector3 edgePosition = mesh.getNodePosition3(n[0]) + 0.5 * edgeVector;
			double sum = 0;
			for (uint j = 0; j < valueWeights1D.size(); ++j) {
				Vector3 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
				sum += valueWeights1D[j] * edgeVector.dot(fn(evaluationPoint));
			}
			discreteForm[i] = 0.5 * sum;
		}
	}

	//discretise 1-form in 4D as 1-cochain by integrating numerically
	void discretise1Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<Vector4(Vector4)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			const Buffer<uint>& n = mesh.getEdgeNodes(i);
			Vector4 edgeVector = mesh.getNodePosition(n[1]) - mesh.getNodePosition(n[0]);
			Vector4 edgePosition = mesh.getNodePosition(n[0]) + 0.5 * edgeVector;
			double sum = 0;
			for (uint j = 0; j < valueWeights1D.size(); ++j) {
				Vector4 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
				sum += valueWeights1D[j] * edgeVector.dot(fn(evaluationPoint));
			}
			discreteForm[i] = 0.5 * sum;
		}
	}

	//discretise 1-form in 2D as 1-cochain by integrating numerically over circumcentric dual edges
	void discretise1FormDualMesh(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<Vector2(Vector2)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			Vector2 edgeVector = mesh.getEdgeDualVector2(i);
			Vector2 edgePosition = mesh.getEdgeDualAverage2(i);
			double sum = 0;
			for (uint j = 0; j < valueWeights1D.size(); ++j) {
				Vector2 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
				sum += valueWeights1D[j] * edgeVector.dot(fn(evaluationPoint));
			}
			discreteForm[i] = 0.5 * sum;
		}
	}

	//discretises the 1-form in 3D that is the gradient of fn
	void discretise1FormWithPotential(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector3)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			const Buffer<uint>& n = mesh.getEdgeNodes(i);
			discreteForm[i] = fn(mesh.getNodePosition3(n[1])) - fn(mesh.getNodePosition3(n[0]));
		}
	}

	/*
	Discretise 2-form in 2D as 2-cochain by integrating numerically.
	N.B. discreteForm[i] is interpreted with the positive sign as if getFaceVector(i).xy > 0
	*/
	void discretise2Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector2)>& fn) {
		for (uint i = 0; i < mesh.getFaceSize(); i++) {
			const Buffer<uint> nodes = mesh.getFaceNodes(i);
			double A = std::abs(mesh.getFaceVector2(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights2D.size(); ++j) {
				sum += valueWeights2D[j] * fn(pointWeights2D[j][0] * mesh.getNodePosition2(nodes[0]) + pointWeights2D[j][1] * mesh.getNodePosition2(nodes[1])
					+ pointWeights2D[j][2] * mesh.getNodePosition2(nodes[2]));
			}
			discreteForm[i] = A * sum;
		}
	}

	/*
	Discretise 2-form in 3D as 2-cochain by integrating numerically.
	Assumes the correspondence between 2-forms and vector fields in 3D.
	*/
	void discretise2Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<Vector3(Vector3)>& fn) {
		for (uint i = 0; i < mesh.getFaceSize(); i++) {
			const Buffer<uint> nodes = mesh.getFaceNodes(i);
			Vector3 faceVector = mesh.getFaceVector3(i).dual();
			double sum = 0;
			for (uint j = 0; j < valueWeights2D.size(); ++j) {
				sum += valueWeights2D[j] * faceVector.dot(fn(pointWeights2D[j][0] * mesh.getNodePosition3(nodes[0])
					+ pointWeights2D[j][1] * mesh.getNodePosition3(nodes[1]) + pointWeights2D[j][2] * mesh.getNodePosition3(nodes[2])));
			}
			discreteForm[i] = sum;
		}
	}

	/*
	Discretise 3-form in 3D as 3-cochain by integrating numerically.
	N.B. discreteForm[i] is interpreted with the positive sign as if getBodyVector(i).xyz > 0
	*/
	void discretise3Form(const Mesh& mesh, Buffer<double>& discreteForm, const std::function<double(Vector3)>& fn) {
		for (uint i = 0; i < mesh.getBodySize(); i++) {
			const Buffer<uint> nodes = mesh.getBodyNodes(i);
			double V = std::abs(mesh.getBodyVector3(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights3D.size(); ++j) {
				sum += valueWeights3D[j] * fn(pointWeights3D[j][0] * mesh.getNodePosition3(nodes[0]) + pointWeights3D[j][1] * mesh.getNodePosition3(nodes[1])
					+ pointWeights3D[j][2] * mesh.getNodePosition3(nodes[2]) + pointWeights3D[j][3] * mesh.getNodePosition3(nodes[3]));
			}
			discreteForm[i] = V * sum;
		}
	}

	//integrate fn over the dual cell of edge
	double integrateDual1Cell(const Mesh& mesh, uint edge, const std::function<Vector2(Vector2)>& fn, bool circumcentric) {
			Vector2 edgePosition = circumcentric ? mesh.getEdgePosition2(edge) : mesh.getEdgeAverage2(edge);
			const Buffer<uint>& faces = mesh.getEdgeFaces(edge);
			double sum = 0;
			for (uint i = 0; i < faces.size(); ++i) {
				Vector2 facePosition = circumcentric ? mesh.getFacePosition2(faces[i]) : mesh.getFaceAverage2(faces[i]);
				Vector2 edgeVector = facePosition - edgePosition;
				if (mesh.getFaceIncidence(faces[i], edge) * mesh.getFaceDualVector2(faces[i]) < 0)
					edgeVector *= -1.0;
				Vector2 midpoint = (facePosition + edgePosition) / 2;
				for (uint j = 0; j < valueWeights1D.size(); ++j) {
					Vector2 evaluationPoint = midpoint + abscissas[j] * 0.5 * edgeVector;
					sum += valueWeights1D[j] * edgeVector.dot(fn(evaluationPoint));
				}
			}
			return 0.5 * sum;
	}

	//integrate fn over the dual cell of node
	double integrateDual2Cell(const Mesh& mesh, uint node, const std::function<double(Vector2)>& fn, bool circumcentric) {
		Vector2 p0 = mesh.getNodePosition2(node);
		Buffer<uint> faces = mesh.getNodeFaces(node);
		const Buffer<uint>& edges = mesh.getNodeEdges(node);
		double result = 0.0;
		for (uint f = 0; f < faces.size(); ++f) {
			Buffer<uint> faceEdges = edges.getIntersection(mesh.getFaceEdges(faces[f]));
			Vector2 face_bc, edge0_bc, edge1_bc;
			if (circumcentric) {
				face_bc = mesh.getFacePosition2(faces[f]);
				edge0_bc = mesh.getEdgePosition2(faceEdges[0]);
				edge1_bc = mesh.getEdgePosition2(faceEdges[1]);
			}
			else {
				face_bc = mesh.getFaceAverage2(faces[f]);
				edge0_bc = mesh.getEdgeAverage2(faceEdges[0]);
				edge1_bc = mesh.getEdgeAverage2(faceEdges[1]);
			}
			result += integralAverage(fn, p0, face_bc, edge0_bc) * std::abs(TwoVector2(face_bc - p0, edge0_bc - p0).determinant()) / 2.0;
			result += integralAverage(fn, p0, face_bc, edge1_bc) * std::abs(TwoVector2(face_bc - p0, edge1_bc - p0).determinant()) / 2.0;
		}
		return result;
	}

	//Integrate fn over the dual cell of node. For integration, the dual cell is divided into simplices whose size is not larger than maxSize.
	double integrateDual2CellInParts(const Mesh& mesh, uint node, const std::function<double(Vector2)>& fn, double maxSize, bool circumcentric) {
		Vector2 p0 = mesh.getNodePosition2(node);
		Buffer<uint> faces = mesh.getNodeFaces(node);
		const Buffer<uint>& edges = mesh.getNodeEdges(node);
		double result = 0.0;
		for (uint f = 0; f < faces.size(); ++f) {
			Buffer<uint> faceEdges = edges.getIntersection(mesh.getFaceEdges(faces[f]));
			Vector2 face_bc, edge0_bc, edge1_bc;
			if (circumcentric) {
				face_bc = mesh.getFacePosition2(faces[f]);
				edge0_bc = mesh.getEdgePosition2(faceEdges[0]);
				edge1_bc = mesh.getEdgePosition2(faceEdges[1]);
			}
			else {
				face_bc = mesh.getFaceAverage2(faces[f]);
				edge0_bc = mesh.getEdgeAverage2(faceEdges[0]);
				edge1_bc = mesh.getEdgeAverage2(faceEdges[1]);
			}
			result += triangleIntegral(fn, p0, edge0_bc, face_bc, maxSize);
			result += triangleIntegral(fn, p0, edge1_bc, face_bc, maxSize);
		}
		return result;
	}

	//integrate fn over the dual cell of edge
	double integrateDual2Cell(const Mesh& mesh, uint edge, const std::function<Vector3(Vector3)>& fn, bool circumcentric) {
		const Buffer<uint>& nodes = mesh.getEdgeNodes(edge);
		const Buffer<uint>& faces = mesh.getEdgeFaces(edge);
		const Buffer<uint> bodies = mesh.getEdgeBodies(edge);
		Vector3 p0 = mesh.getNodePosition3(nodes[0]);
		Vector3 p1 = mesh.getNodePosition3(nodes[1]);
		Vector3 edgeVector = p1 - p0;
		Vector3 edge_bc = circumcentric ? mesh.getEdgePosition3(edge) : mesh.getEdgeAverage3(edge);
		double sum = 0.0;
		for (uint b = 0; b < bodies.size(); ++b) {
			Buffer<uint> bodyFaces = faces.getIntersection(mesh.getBodyFaces(bodies[b]));
			Vector3 face0_bc, face1_bc, body_bc;
			if (circumcentric) {
				face0_bc = mesh.getFacePosition3(bodyFaces[0]);
				face1_bc = mesh.getFacePosition3(bodyFaces[1]);
				body_bc = mesh.getBodyPosition3(bodies[b]);
			}
			else {
				face0_bc = mesh.getFaceAverage3(bodyFaces[0]);
				face1_bc = mesh.getFaceAverage3(bodyFaces[1]);
				body_bc = mesh.getBodyAverage3(bodies[b]);
			}
			Vector3 face0Normal = 0.5 * TwoVector3(face0_bc - edge_bc, body_bc - edge_bc).dual();
			if (face0Normal.dot(edgeVector) < 0)
				face0Normal *= -1.0;
			Vector3 face1Normal = 0.5 * TwoVector3(face1_bc - edge_bc, body_bc - edge_bc).dual();
			if (face1Normal.dot(edgeVector) < 0)
				face1Normal *= -1.0;
			for (uint i = 0; i < valueWeights2D.size(); ++i) {
				sum += valueWeights2D[i] * face0Normal.dot(fn(pointWeights2D[i][0] * face0_bc + pointWeights2D[i][1] * body_bc + pointWeights2D[i][2] * edge_bc));
				sum += valueWeights2D[i] * face1Normal.dot(fn(pointWeights2D[i][0] * face1_bc + pointWeights2D[i][1] * body_bc + pointWeights2D[i][2] * edge_bc));
			}
		}
		return sum;
	}

	//integrate fn over the dual cell of edge in Cartesian mesh
	double integrateDual2CellCartesianMesh(const Mesh& mesh, uint edge, const std::function<Vector3(Vector3)>& fn) {
		const Buffer<uint>& faces = mesh.getEdgeFaces(edge);
		const Buffer<uint> bodies = mesh.getEdgeBodies(edge);
		Vector3 edgeVector = mesh.getEdgeVector3(edge);
		Vector3 edge_bc = mesh.getEdgeAverage3(edge);
		double sum = 0.0;
		for (uint b = 0; b < bodies.size(); ++b) {
			Buffer<uint> bodyFaces = faces.getIntersection(mesh.getBodyFaces(bodies[b]));
			Vector3 face0_bc(0, 0, 0);
			Vector3 face1_bc(0, 0, 0);
			Vector3 body_bc(0, 0, 0);
			const Buffer<uint> face0Nodes = mesh.getFaceNodes(bodyFaces[0]);
			const Buffer<uint> face1Nodes = mesh.getFaceNodes(bodyFaces[1]);
			const Buffer<uint> bodyNodes = mesh.getBodyNodes(bodies[b]);
			for (uint i = 0; i < face0Nodes.size(); ++i) {
				face0_bc += mesh.getNodePosition3(face0Nodes[i]);
			}
			for (uint i = 0; i < face1Nodes.size(); ++i) {
				face1_bc += mesh.getNodePosition3(face1Nodes[i]);
			}
			for (uint i = 0; i < bodyNodes.size(); ++i) {
				body_bc += mesh.getNodePosition3(bodyNodes[i]);
			}
			face0_bc *= 0.25;
			face1_bc *= 0.25;
			body_bc *= 0.125;
			double area = (body_bc - face0_bc).len() * (body_bc - face1_bc).len();
			std::function<double(Vector3)> interpolant;
			if (isXDir(edgeVector))
				interpolant = [&](Vector3 p) -> double { return fn(p).x; };
			else if (isYDir(edgeVector))
				interpolant = [&](Vector3 p) -> double { return fn(p).y; };
			else
				interpolant = [&](Vector3 p) -> double { return fn(p).z; };
			sum += 0.5 * area * (integralAverage(interpolant, edge_bc, face0_bc, body_bc) + integralAverage(interpolant, edge_bc, face1_bc, body_bc));
		}
		return sum;
	}

	//integrate fn over the dual cell of node
	double integrateDual3Cell(const Mesh& mesh, uint node, const std::function<double(Vector3)>& fn, bool circumcentric) {
		Vector3 p0 = mesh.getNodePosition3(node);
		Buffer<uint> bodies = mesh.getNodeBodies(node);
		Buffer<uint> faces = mesh.getNodeFaces(node);
		double result = 0.0;
		for (uint b = 0; b < bodies.size(); ++b) {
			Buffer<uint> bodyFaces = faces.getIntersection(mesh.getBodyFaces(bodies[b]));
			Vector3 body_bc, face0_bc, face1_bc, face2_bc, edge01_bc, edge02_bc, edge12_bc;
			if (circumcentric) {
				body_bc = mesh.getBodyPosition3(bodies[b]);
				face0_bc = mesh.getFacePosition3(bodyFaces[0]);
				face1_bc = mesh.getFacePosition3(bodyFaces[1]);
				face2_bc = mesh.getFacePosition3(bodyFaces[2]);
				edge01_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[1]));
				edge02_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[2]));
				edge12_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[1], bodyFaces[2]));
			}
			else {
				body_bc = mesh.getBodyAverage3(bodies[b]);
				face0_bc = mesh.getFaceAverage3(bodyFaces[0]);
				face1_bc = mesh.getFaceAverage3(bodyFaces[1]);
				face2_bc = mesh.getFaceAverage3(bodyFaces[2]);
				edge01_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[1]));
				edge02_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[2]));
				edge12_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[1], bodyFaces[2]));
			}
			result += integralAverage(fn, p0, body_bc, edge01_bc, face0_bc) * std::abs(ThreeVector3(body_bc - p0, edge01_bc - p0, face0_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge01_bc, face1_bc) * std::abs(ThreeVector3(body_bc - p0, edge01_bc - p0, face1_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge02_bc, face0_bc) * std::abs(ThreeVector3(body_bc - p0, edge02_bc - p0, face0_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge02_bc, face2_bc) * std::abs(ThreeVector3(body_bc - p0, edge02_bc - p0, face2_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge12_bc, face1_bc) * std::abs(ThreeVector3(body_bc - p0, edge12_bc - p0, face1_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge12_bc, face2_bc) * std::abs(ThreeVector3(body_bc - p0, edge12_bc - p0, face2_bc - p0).determinant()) / 6.0;
		}
		return result;
	}

	//Integrate fn over the dual cell of node. For integration, the dual cell is divided into simplices whose size is not larger than maxSize.
	double integrateDual3CellInParts(const Mesh& mesh, uint node, const std::function<double(Vector3)>& fn, double maxSize, bool circumcentric) {
		Vector3 p0 = mesh.getNodePosition3(node);
		Buffer<uint> bodies = mesh.getNodeBodies(node);
		Buffer<uint> faces = mesh.getNodeFaces(node);
		double result = 0.0;
		for (uint b = 0; b < bodies.size(); ++b) {
			Buffer<uint> bodyFaces = faces.getIntersection(mesh.getBodyFaces(bodies[b]));
			Vector3 body_bc, face0_bc, face1_bc, face2_bc, edge01_bc, edge02_bc, edge12_bc;
			if (circumcentric) {
				body_bc = mesh.getBodyPosition3(bodies[b]);
				face0_bc = mesh.getFacePosition3(bodyFaces[0]);
				face1_bc = mesh.getFacePosition3(bodyFaces[1]);
				face2_bc = mesh.getFacePosition3(bodyFaces[2]);
				edge01_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[1]));
				edge02_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[2]));
				edge12_bc = mesh.getEdgePosition3(mesh.getFaceIntersection(bodyFaces[1], bodyFaces[2]));
			}
			else {
				body_bc = mesh.getBodyAverage3(bodies[b]);
				face0_bc = mesh.getFaceAverage3(bodyFaces[0]);
				face1_bc = mesh.getFaceAverage3(bodyFaces[1]);
				face2_bc = mesh.getFaceAverage3(bodyFaces[2]);
				edge01_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[1]));
				edge02_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[2]));
				edge12_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[1], bodyFaces[2]));
			}
			result += tetrahedronIntegral(fn, p0, edge01_bc, face0_bc, body_bc, maxSize);
			result += tetrahedronIntegral(fn, p0, edge01_bc, face1_bc, body_bc, maxSize);
			result += tetrahedronIntegral(fn, p0, edge02_bc, face0_bc, body_bc, maxSize);
			result += tetrahedronIntegral(fn, p0, edge02_bc, face2_bc, body_bc, maxSize);
			result += tetrahedronIntegral(fn, p0, edge12_bc, face1_bc, body_bc, maxSize);
			result += tetrahedronIntegral(fn, p0, edge12_bc, face2_bc, body_bc, maxSize);
		}
		return result;
	}

	//integrate fn over the dual cell of node in Cartesian mesh
	double integrateDual3CellCartesianMesh(const Mesh& mesh, uint node, const std::function<double(Vector3)>& fn) {
		Vector3 p0 = mesh.getNodePosition3(node);
		Buffer<uint> bodies = mesh.getNodeBodies(node);
		Buffer<uint> faces = mesh.getNodeFaces(node);
		double result = 0.0;
		for (uint b = 0; b < bodies.size(); ++b) {
			Buffer<uint> bodyFaces = faces.getIntersection(mesh.getBodyFaces(bodies[b]));
			Vector3 body_bc, face0_bc, face1_bc, face2_bc, edge01_bc, edge02_bc, edge12_bc;
			edge01_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[1]));
			edge02_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[0], bodyFaces[2]));
			edge12_bc = mesh.getEdgeAverage3(mesh.getFaceIntersection(bodyFaces[1], bodyFaces[2]));
			Buffer<uint> face0Nodes = mesh.getFaceNodes(bodyFaces[0]);
			face0_bc = 0.25 * (mesh.getNodePosition3(face0Nodes[0]) + mesh.getNodePosition3(face0Nodes[1]) + mesh.getNodePosition3(face0Nodes[2]) + mesh.getNodePosition3(face0Nodes[3]));
			Buffer<uint> face1Nodes = mesh.getFaceNodes(bodyFaces[1]);
			face1_bc = 0.25 * (mesh.getNodePosition3(face1Nodes[0]) + mesh.getNodePosition3(face1Nodes[1]) + mesh.getNodePosition3(face1Nodes[2]) + mesh.getNodePosition3(face1Nodes[3]));
			Buffer<uint> face2Nodes = mesh.getFaceNodes(bodyFaces[2]);
			face2_bc = 0.25 * (mesh.getNodePosition3(face2Nodes[0]) + mesh.getNodePosition3(face2Nodes[1]) + mesh.getNodePosition3(face2Nodes[2]) + mesh.getNodePosition3(face2Nodes[3]));
			body_bc = edge01_bc + (edge02_bc - p0) + (edge12_bc - p0);
			result += integralAverage(fn, p0, body_bc, edge01_bc, face0_bc) * std::abs(ThreeVector3(body_bc - p0, edge01_bc - p0, face0_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge01_bc, face1_bc) * std::abs(ThreeVector3(body_bc - p0, edge01_bc - p0, face1_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge02_bc, face0_bc) * std::abs(ThreeVector3(body_bc - p0, edge02_bc - p0, face0_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge02_bc, face2_bc) * std::abs(ThreeVector3(body_bc - p0, edge02_bc - p0, face2_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge12_bc, face1_bc) * std::abs(ThreeVector3(body_bc - p0, edge12_bc - p0, face1_bc - p0).determinant()) / 6.0;
			result += integralAverage(fn, p0, body_bc, edge12_bc, face2_bc) * std::abs(ThreeVector3(body_bc - p0, edge12_bc - p0, face2_bc - p0).determinant()) / 6.0;
		}
		return result;
	}

	//integrate fn through the intersection of mesh boundary and the boundary of the dual cell of node
	double integrateNodeDualBoundary(const Mesh& mesh, uint node, const std::function<Vector2(Vector2)>& fn, bool circumcentric, bool minkowskiMetric) {
		Vector2 pos = mesh.getNodePosition2(node);
		const Buffer<uint>& edges = mesh.getNodeEdges(node);
		double result = 0.0;
		for (uint j = 0; j < edges.size(); ++j) {
			if (mesh.getEdgeFaces(edges[j]).size() != 1)
				continue;
			Vector2 edge_bc = circumcentric ? mesh.getEdgePosition2(edges[j]) : mesh.getEdgeAverage2(edges[j]);
			Vector2 face_bc = mesh.getFaceAverage2(mesh.getEdgeFaces(edges[j])[0]);
			Vector2 normalVector(pos.y - edge_bc.y, edge_bc.x - pos.x);
			if (normalVector.dot(edge_bc - face_bc) < 0)
				normalVector *= -1.0;
			if (minkowskiMetric)
				normalVector.y = -normalVector.y;
			std::function<double(Vector2)> normalComponent{
				[&](Vector2 p) -> double {
					return fn(p).dot(normalVector);
				}
			};
			result += integralAverage(normalComponent, pos, edge_bc);
		}
		return result;
	}

	//integrate fn through the intersection of mesh boundary and the boundary of the dual cell of node
	double integrateNodeDualBoundary(const Mesh& mesh, uint node, const std::function<Vector3(Vector3)>& fn, bool circumcentric, bool minkowskiMetric) {
		Vector3 pos = mesh.getNodePosition3(node);
		const Buffer<uint>& edges = mesh.getNodeEdges(node);
		const Buffer<uint> faces = mesh.getNodeFaces(node);
		double result = 0.0;
		for (uint j = 0; j < faces.size(); ++j) {
			if (mesh.getFaceBodies(faces[j]).size() != 1)
				continue;
			Buffer<uint> faceEdges = edges.getIntersection(mesh.getFaceEdges(faces[j]));
			Vector3 edge0_bc = circumcentric ? mesh.getEdgePosition3(faceEdges[0]) : mesh.getEdgeAverage3(faceEdges[0]);
			Vector3 edge1_bc = circumcentric ? mesh.getEdgePosition3(faceEdges[1]) : mesh.getEdgeAverage3(faceEdges[1]);
			Vector3 face_bc = circumcentric ? mesh.getFacePosition3(faces[j]) : mesh.getFaceAverage3(faces[j]);
			Vector3 body_bc = mesh.getBodyAverage3(mesh.getFaceBodies(faces[j])[0]);
			Vector3 normalVector0 = 0.5 * TwoVector3(edge0_bc - pos, face_bc - pos).dual();
			if (normalVector0.dot(face_bc - body_bc) < 0)
				normalVector0 *= -1.0;
			Vector3 normalVector1 = 0.5 * TwoVector3(edge1_bc - pos, face_bc - pos).dual();
			if (normalVector1.dot(face_bc - body_bc) < 0)
				normalVector1 *= -1.0;
			if (minkowskiMetric) {
				normalVector0.z = -normalVector0.z;
				normalVector1.z = -normalVector1.z;
			}
			result += integralAverage([&](Vector3 p) -> double { return fn(p).dot(normalVector0); }, pos, edge0_bc, face_bc);
			result += integralAverage([&](Vector3 p) -> double { return fn(p).dot(normalVector1); }, pos, edge1_bc, face_bc);
		}
		return result;
	}

	//integrate fn through the intersection of mesh boundary and the boundary of the dual cell of node in Cartesian mesh
	double integrateNodeDualBoundaryCartesianMesh(const Mesh& mesh, uint node, const std::function<Vector3(Vector3)>& fn, bool minkowskiMetric) {
		Vector3 pos = mesh.getNodePosition3(node);
		const Buffer<uint>& edges = mesh.getNodeEdges(node);
		const Buffer<uint> faces = mesh.getNodeFaces(node);
		double result = 0.0;
		for (uint j = 0; j < faces.size(); ++j) {
			if (mesh.getFaceBodies(faces[j]).size() != 1)
				continue;
			Buffer<uint> faceEdges = edges.getIntersection(mesh.getFaceEdges(faces[j]));
			Vector3 edge0_bc = mesh.getEdgeAverage3(faceEdges[0]);
			Vector3 edge1_bc = mesh.getEdgeAverage3(faceEdges[1]);
			Buffer<uint> faceNodes = mesh.getFaceNodes(faces[j]);
			Vector3 face_bc = 0.25 * (mesh.getNodePosition3(faceNodes[0]) + mesh.getNodePosition3(faceNodes[1]) + mesh.getNodePosition3(faceNodes[2]) + mesh.getNodePosition3(faceNodes[3]));
			double area = (face_bc - edge0_bc).len() * (face_bc - edge1_bc).len();
			Vector3 body_bc = mesh.getBodyAverage3(mesh.getFaceBodies(faces[j])[0]);
			Vector3 normalVector = mesh.getFaceDualVector3(faces[j]);
			if (isXDir(normalVector))
				normalVector = Vector3(1.0, 0.0, 0.0);
			else if (isYDir(normalVector))
				normalVector = Vector3(0.0, 1.0, 0.0);
			else
				normalVector = Vector3(0.0, 0.0, 1.0);
			if (normalVector.dot(face_bc - body_bc) < 0.0)
				normalVector *= -1.0;
			if (minkowskiMetric)
				normalVector.z = -normalVector.z;
			result += 0.5 * area * (integralAverage([&](Vector3 p) -> double { return fn(p).dot(normalVector); }, pos, edge0_bc, face_bc)
				+ integralAverage([&](Vector3 p) -> double { return fn(p).dot(normalVector); }, pos, edge1_bc, face_bc));
		}
		return result;
	}

	//computes the means of the scalar function fn over edges of the mesh
	void integrateEdges(const Mesh& mesh, Buffer<double>& means, const std::function<double(Vector4)>& fn) {
		for (uint i = 0; i < mesh.getEdgeSize(); i++)
		{
			const Buffer<uint>& n = mesh.getEdgeNodes(i);
			Vector4 edgeVector = mesh.getNodePosition(n[1]) - mesh.getNodePosition(n[0]);
			Vector4 edgePosition = mesh.getNodePosition(n[0]) + 0.5 * edgeVector;
			double sum = 0;
			for (uint j = 0; j < valueWeights1D.size(); ++j) {
				Vector4 evaluationPoint = edgePosition + abscissas[j] * 0.5 * edgeVector;
				sum += valueWeights1D[j] * fn(evaluationPoint);
			}
			means[i] = 0.5 * sum;
		}
	}

	//computes the means of the scalar function fn over triangles of the mesh
	void integrateTriangles(const Mesh& mesh, Buffer<double>& means, const std::function<double(Vector4)>& fn) {
		for (uint i = 0; i < mesh.getFaceSize(); i++) {
			const Buffer<uint> nodes = mesh.getFaceNodes(i);
			double sum = 0;
			for (uint j = 0; j < valueWeights2D.size(); ++j) {
				sum += valueWeights2D[j] * fn(pointWeights2D[j][0] * mesh.getNodePosition(nodes[0])
					+ pointWeights2D[j][1] * mesh.getNodePosition(nodes[1]) + pointWeights2D[j][2] * mesh.getNodePosition(nodes[2]));
			}
			means[i] = sum;
		}
	}

	//estimate the square of the L2 norm of fn by integrating numerically
	double computeL2NormSquared(const Mesh& mesh, const std::function<double(Vector2)>& fn) {
		double l2NormSquared = 0.0;
		for (uint i = 0; i < mesh.getFaceSize(); i++) {
			const Buffer<uint> nodes = mesh.getFaceNodes(i);
			double A = std::abs(mesh.getFaceVector2(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights2D.size(); ++j) {
				sum += valueWeights2D[j] * std::pow(fn(pointWeights2D[j][0] * mesh.getNodePosition2(nodes[0]) + pointWeights2D[j][1] * mesh.getNodePosition2(nodes[1])
					+ pointWeights2D[j][2] * mesh.getNodePosition2(nodes[2])), 2);
			}
			l2NormSquared += A * sum;
		}
		return l2NormSquared;
	}

	//estimate the square of the L2 norm of fn by integrating numerically
	double computeL2NormSquared(const Mesh& mesh, const std::function<double(Vector3)>& fn) {
		double l2NormSquared = 0.0;
		for (uint i = 0; i < mesh.getBodySize(); i++) {
			const Buffer<uint> nodes = mesh.getBodyNodes(i);
			double V = std::abs(mesh.getBodyVector3(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights3D.size(); ++j) {
				sum += valueWeights3D[j] * std::pow(fn(pointWeights3D[j][0] * mesh.getNodePosition3(nodes[0]) + pointWeights3D[j][1] * mesh.getNodePosition3(nodes[1])
					+ pointWeights3D[j][2] * mesh.getNodePosition3(nodes[2]) + pointWeights3D[j][3] * mesh.getNodePosition3(nodes[3])), 2);
			}
			l2NormSquared += V * sum;
		}
		return l2NormSquared;
	}

	//estimate the square of the L2 norm of |fn| by integrating numerically	
	double computeL2NormSquared(const Mesh& mesh, const std::function<Vector2(Vector2)>& fn) {
		double l2NormSquared = 0.0;
		for (uint i = 0; i < mesh.getFaceSize(); i++) {
			const Buffer<uint> nodes = mesh.getFaceNodes(i);
			double A = std::abs(mesh.getFaceVector2(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights2D.size(); ++j) {
				sum += valueWeights2D[j] * fn(pointWeights2D[j][0] * mesh.getNodePosition2(nodes[0]) + pointWeights2D[j][1] * mesh.getNodePosition2(nodes[1])
					+ pointWeights2D[j][2] * mesh.getNodePosition2(nodes[2])).lensq();
			}
			l2NormSquared += A * sum;
		}
		return l2NormSquared;
	}

	//estimate the square of the L2 norm of |fn| by integrating numerically
	double computeL2NormSquared(const Mesh& mesh, const std::function<Vector3(Vector3)>& fn) {
		double l2NormSquared = 0.0;
		for (uint i = 0; i < mesh.getBodySize(); i++) {
			const Buffer<uint> nodes = mesh.getBodyNodes(i);
			double V = std::abs(mesh.getBodyVector3(i).determinant());
			double sum = 0;
			for (uint j = 0; j < valueWeights3D.size(); ++j) {
				sum += valueWeights3D[j] * fn(pointWeights3D[j][0] * mesh.getNodePosition3(nodes[0]) + pointWeights3D[j][1] * mesh.getNodePosition3(nodes[1])
					+ pointWeights3D[j][2] * mesh.getNodePosition3(nodes[2]) + pointWeights3D[j][3] * mesh.getNodePosition3(nodes[3])).lensq();
			}
			l2NormSquared += V * sum;
		}
		return l2NormSquared;
	}

	//estimate the square of the L2 norm of |fn| by integrating numerically in Cartesian mesh
	double computeL2NormSquaredCartesianMesh(const Mesh& mesh, const std::function<Vector3(Vector3)>& fn) {
		double l2NormSquared = 0.0;
		for (uint i = 0; i < mesh.getBodySize(); i++) {
			const Buffer<uint> nodes = getCubeNodes(i, mesh);
			Vector3 p0 = mesh.getNodePosition3(nodes[0]);
			Vector3 p1 = mesh.getNodePosition3(nodes[1]);
			Vector3 p2 = mesh.getNodePosition3(nodes[2]);
			Vector3 p3 = mesh.getNodePosition3(nodes[3]);
			Vector3 p4 = mesh.getNodePosition3(nodes[4]);
			Vector3 p5 = mesh.getNodePosition3(nodes[5]);
			Vector3 p6 = mesh.getNodePosition3(nodes[6]);
			Vector3 p7 = mesh.getNodePosition3(nodes[7]);
			double V = (p1.x - p0.x) * (p3.y - p0.y) * (p4.z - p0.z) / 6;
			std::function<double(Vector3)> lensqu{
			[&fn](Vector3 p) -> double {
				return fn(p).lensq();
			}
			};
			l2NormSquared += V * (integralAverage(lensqu, p0, p1, p2, p4) + integralAverage(lensqu, p1, p2, p4, p5) + integralAverage(lensqu, p2, p4, p5, p6)
				+ integralAverage(lensqu, p0, p2, p3, p4) + integralAverage(lensqu, p2, p3, p4, p7) + integralAverage(lensqu, p2, p4, p6, p7));
		}
		return l2NormSquared;
	}

	//Computes the integral of fn over the triangle with the given nodes in 2D. Triangle is divided into smaller triangles if its size is larger than the requested maximum.
	double triangleIntegral(const std::function<double(Vector2)>& fn, const Vector2& node0, const Vector2& node1, const Vector2& node2, const double maxSize) {
		if ((node2 - node0).len() <= maxSize) {
			return integralAverage(fn, node0, node1, node2) * std::abs(TwoVector2(node1 - node0, node2 - node0).determinant()) / 2.0;
		}
		Vector2 node01 = 0.5 * (node0 + node1);
		Vector2 node02 = 0.5 * (node0 + node2);
		Vector2 node12 = 0.5 * (node1 + node2);
		return triangleIntegral(fn, node0, node01, node02, maxSize) + triangleIntegral(fn, node1, node01, node02, maxSize) + triangleIntegral(fn, node1, node12, node02, maxSize)
			+ triangleIntegral(fn, node2, node12, node02, maxSize);
	}

	//Computes the integral of fn over the tetrahedron with the given nodes in 3D. Tetrahedron is divided into smaller tetrahedra if its size is larger than the requested maximum.
	double tetrahedronIntegral(const std::function<double(Vector3)>& fn, const Vector3& node0, const Vector3& node1, const Vector3& node2, const Vector3& node3, const double maxSize) {
		if ((node3 - node0).len() <= maxSize) {
			return integralAverage(fn, node0, node1, node2, node3) * std::abs(ThreeVector3(node1 - node0, node2 - node0, node3 - node0).determinant()) / 6.0;
		}
		Vector3 node01 = 0.5 * (node0 + node1);
		Vector3 node02 = 0.5 * (node0 + node2);
		Vector3 node03 = 0.5 * (node0 + node3);
		Vector3 node12 = 0.5 * (node1 + node2);
		Vector3 node13 = 0.5 * (node1 + node3);
		Vector3 node23 = 0.5 * (node2 + node3);
		return tetrahedronIntegral(fn, node0, node01, node02, node03, maxSize) + tetrahedronIntegral(fn, node1, node01, node02, node03, maxSize)
			+ tetrahedronIntegral(fn, node1, node12, node02, node03, maxSize) + tetrahedronIntegral(fn, node2, node12, node02, node03, maxSize)
			+ tetrahedronIntegral(fn, node1, node12, node13, node03, maxSize) + tetrahedronIntegral(fn, node2, node12, node13, node03, maxSize)
			+ tetrahedronIntegral(fn, node2, node23, node13, node03, maxSize) + tetrahedronIntegral(fn, node3, node23, node13, node03, maxSize);
	}

	//Computes the integral of fn over the parallelogram with the given vertices. The parallelogram is divided into smaller quadrilaterals if p1 - p0 is longer than the requested maximum.
	double parallelogramIntegral(const std::function<double(Vector2)>& fn, const Vector2& p0, const Vector2& p1, const Vector2& p2, const Vector2& p3, const double maxSize) {
		if ((p1 - p0).len() <= maxSize) {
			double V = (p1.x - p0.x) * (p3.y - p0.y) / 2;
			return V * (integralAverage(fn, p0, p1, p3) + integralAverage(fn, p1, p2, p3));
		}
		Vector2 p01 = 0.5 * (p0 + p1);
		Vector2 p02 = 0.5 * (p0 + p3);
		Vector2 p12 = p01 + p02 - p0;
		Vector2 edge1 = 0.5 * (p1 - p0);
		Vector2 edge2 = 0.5 * (p3 - p0);
		return parallelogramIntegral(fn, p0, p0 + edge1, p0 + edge1 + edge2, p0 + edge2, maxSize)
			+ parallelogramIntegral(fn, p01, p01 + edge1, p01 + edge1 + edge2, p01 + edge2, maxSize)
			+ parallelogramIntegral(fn, p02, p02 + edge1, p02 + edge1 + edge2, p02 + edge2, maxSize)
			+ parallelogramIntegral(fn, p12, p12 + edge1, p12 + edge1 + edge2, p12 + edge2, maxSize);
	}

	//Computes the integral of fn over the parallelepiped with the given vertices. The parallelepiped is divided into smaller cuboids if p1 - p0 is longer than the requested maximum.
	double parallelepipedIntegral(const std::function<double(Vector3)>& fn, const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3,
		const Vector3& p4, const Vector3& p5, const Vector3& p6, const Vector3& p7, const double maxSize) {
		if ((p1 - p0).len() <= maxSize) {
			double V = (p1.x - p0.x) * (p3.y - p0.y) * (p4.z - p0.z) / 6;
			return V * (integralAverage(fn, p0, p1, p2, p4) + integralAverage(fn, p1, p2, p4, p5) + integralAverage(fn, p2, p4, p5, p6)
				+ integralAverage(fn, p0, p2, p3, p4) + integralAverage(fn, p2, p3, p4, p7) + integralAverage(fn, p2, p4, p6, p7));
		}
		Vector3 p01 = 0.5 * (p0 + p1);
		Vector3 p02 = 0.5 * (p0 + p3);
		Vector3 p03 = 0.5 * (p0 + p4);
		Vector3 p12 = p01 + p02 - p0;
		Vector3 p13 = p01 + p03 - p0;
		Vector3 p23 = p02 + p03 - p0;
		Vector3 p123 = p12 + p03 - p0;
		Vector3 edge1 = 0.5 * (p1 - p0);
		Vector3 edge2 = 0.5 * (p3 - p0);
		Vector3 edge3 = 0.5 * (p4 - p0);
		return parallelepipedIntegral(fn, p0, p0 + edge1, p0 + edge1 + edge2, p0 + edge2, p0 + edge3, p0 + edge3 + edge1, p0 + edge3 + edge1 + edge2, p0 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p01, p01 + edge1, p01 + edge1 + edge2, p01 + edge2, p01 + edge3, p01 + edge3 + edge1, p01 + edge3 + edge1 + edge2, p01 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p02, p02 + edge1, p02 + edge1 + edge2, p02 + edge2, p02 + edge3, p02 + edge3 + edge1, p02 + edge3 + edge1 + edge2, p02 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p03, p03 + edge1, p03 + edge1 + edge2, p03 + edge2, p03 + edge3, p03 + edge3 + edge1, p03 + edge3 + edge1 + edge2, p03 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p12, p12 + edge1, p12 + edge1 + edge2, p12 + edge2, p12 + edge3, p12 + edge3 + edge1, p12 + edge3 + edge1 + edge2, p12 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p13, p13 + edge1, p13 + edge1 + edge2, p13 + edge2, p13 + edge3, p13 + edge3 + edge1, p13 + edge3 + edge1 + edge2, p13 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p23, p23 + edge1, p23 + edge1 + edge2, p23 + edge2, p23 + edge3, p23 + edge3 + edge1, p23 + edge3 + edge1 + edge2, p23 + edge3 + edge2, maxSize)
			+ parallelepipedIntegral(fn, p123, p123 + edge1, p123 + edge1 + edge2, p123 + edge2, p123 + edge3, p123 + edge3 + edge1, p123 + edge3 + edge1 + edge2, p123 + edge3 + edge2, maxSize);
	}
}